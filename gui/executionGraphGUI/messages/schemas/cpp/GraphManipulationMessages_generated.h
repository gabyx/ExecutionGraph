// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GRAPHMANIPULATIONMESSAGES_EXECUTIONGRAPHGUI_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_GRAPHMANIPULATIONMESSAGES_EXECUTIONGRAPHGUI_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"

#include "executionGraphGUI/messages/schemas/ConstructorKeyValue_generated.h"
#include "executionGraphGUI/messages/schemas/CycleDescription_generated.h"
#include "executionGraphGUI/messages/schemas/DataTypes_generated.h"
#include "executionGraph/serialization/schemas/LogicNode_generated.h"
#include "executionGraph/serialization/schemas/LogicSocket_generated.h"
#include "executionGraph/serialization/schemas/SocketLink_generated.h"

namespace executionGraphGUI {
namespace serialization {

struct NodeConstructionInfo;

struct AddNodeRequest;

struct AddNodeResponse;

struct RemoveNodeRequest;

struct AddConnectionRequest;

struct AddConnectionResponse;

struct RemoveConnectionRequest;

struct NodeConstructionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_CONSTRUCTORARGS = 8
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ConstructorKV>> *constructorArgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ConstructorKV>> *>(VT_CONSTRUCTORARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CONSTRUCTORARGS) &&
           verifier.VerifyVector(constructorArgs()) &&
           verifier.VerifyVectorOfTables(constructorArgs()) &&
           verifier.EndTable();
  }
};

struct NodeConstructionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(NodeConstructionInfo::VT_TYPE, type);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NodeConstructionInfo::VT_NAME, name);
  }
  void add_constructorArgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ConstructorKV>>> constructorArgs) {
    fbb_.AddOffset(NodeConstructionInfo::VT_CONSTRUCTORARGS, constructorArgs);
  }
  explicit NodeConstructionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeConstructionInfoBuilder &operator=(const NodeConstructionInfoBuilder &);
  flatbuffers::Offset<NodeConstructionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeConstructionInfo>(end);
    fbb_.Required(o, NodeConstructionInfo::VT_TYPE);
    fbb_.Required(o, NodeConstructionInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NodeConstructionInfo> CreateNodeConstructionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ConstructorKV>>> constructorArgs = 0) {
  NodeConstructionInfoBuilder builder_(_fbb);
  builder_.add_constructorArgs(constructorArgs);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeConstructionInfo> CreateNodeConstructionInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<ConstructorKV>> *constructorArgs = nullptr) {
  return executionGraphGUI::serialization::CreateNodeConstructionInfo(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      name ? _fbb.CreateString(name) : 0,
      constructorArgs ? _fbb.CreateVector<flatbuffers::Offset<ConstructorKV>>(*constructorArgs) : 0);
}

struct AddNodeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPHID = 4,
    VT_NODE = 6
  };
  const flatbuffers::String *graphId() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPHID);
  }
  const NodeConstructionInfo *node() const {
    return GetPointer<const NodeConstructionInfo *>(VT_NODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPHID) &&
           verifier.VerifyString(graphId()) &&
           VerifyOffsetRequired(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct AddNodeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graphId(flatbuffers::Offset<flatbuffers::String> graphId) {
    fbb_.AddOffset(AddNodeRequest::VT_GRAPHID, graphId);
  }
  void add_node(flatbuffers::Offset<NodeConstructionInfo> node) {
    fbb_.AddOffset(AddNodeRequest::VT_NODE, node);
  }
  explicit AddNodeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNodeRequestBuilder &operator=(const AddNodeRequestBuilder &);
  flatbuffers::Offset<AddNodeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNodeRequest>(end);
    fbb_.Required(o, AddNodeRequest::VT_GRAPHID);
    fbb_.Required(o, AddNodeRequest::VT_NODE);
    return o;
  }
};

inline flatbuffers::Offset<AddNodeRequest> CreateAddNodeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> graphId = 0,
    flatbuffers::Offset<NodeConstructionInfo> node = 0) {
  AddNodeRequestBuilder builder_(_fbb);
  builder_.add_node(node);
  builder_.add_graphId(graphId);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddNodeRequest> CreateAddNodeRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *graphId = nullptr,
    flatbuffers::Offset<NodeConstructionInfo> node = 0) {
  return executionGraphGUI::serialization::CreateAddNodeRequest(
      _fbb,
      graphId ? _fbb.CreateString(graphId) : 0,
      node);
}

struct AddNodeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE = 4
  };
  const executionGraph::serialization::LogicNode *node() const {
    return GetPointer<const executionGraph::serialization::LogicNode *>(VT_NODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct AddNodeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<executionGraph::serialization::LogicNode> node) {
    fbb_.AddOffset(AddNodeResponse::VT_NODE, node);
  }
  explicit AddNodeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNodeResponseBuilder &operator=(const AddNodeResponseBuilder &);
  flatbuffers::Offset<AddNodeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNodeResponse>(end);
    fbb_.Required(o, AddNodeResponse::VT_NODE);
    return o;
  }
};

inline flatbuffers::Offset<AddNodeResponse> CreateAddNodeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<executionGraph::serialization::LogicNode> node = 0) {
  AddNodeResponseBuilder builder_(_fbb);
  builder_.add_node(node);
  return builder_.Finish();
}

struct RemoveNodeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPHID = 4,
    VT_NODEID = 6
  };
  const flatbuffers::String *graphId() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPHID);
  }
  uint64_t nodeId() const {
    return GetField<uint64_t>(VT_NODEID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPHID) &&
           verifier.VerifyString(graphId()) &&
           VerifyField<uint64_t>(verifier, VT_NODEID) &&
           verifier.EndTable();
  }
};

struct RemoveNodeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graphId(flatbuffers::Offset<flatbuffers::String> graphId) {
    fbb_.AddOffset(RemoveNodeRequest::VT_GRAPHID, graphId);
  }
  void add_nodeId(uint64_t nodeId) {
    fbb_.AddElement<uint64_t>(RemoveNodeRequest::VT_NODEID, nodeId, 0);
  }
  explicit RemoveNodeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveNodeRequestBuilder &operator=(const RemoveNodeRequestBuilder &);
  flatbuffers::Offset<RemoveNodeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveNodeRequest>(end);
    fbb_.Required(o, RemoveNodeRequest::VT_GRAPHID);
    return o;
  }
};

inline flatbuffers::Offset<RemoveNodeRequest> CreateRemoveNodeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> graphId = 0,
    uint64_t nodeId = 0) {
  RemoveNodeRequestBuilder builder_(_fbb);
  builder_.add_nodeId(nodeId);
  builder_.add_graphId(graphId);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoveNodeRequest> CreateRemoveNodeRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *graphId = nullptr,
    uint64_t nodeId = 0) {
  return executionGraphGUI::serialization::CreateRemoveNodeRequest(
      _fbb,
      graphId ? _fbb.CreateString(graphId) : 0,
      nodeId);
}

struct AddConnectionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPHID = 4,
    VT_SOCKETLINK = 6,
    VT_CHECKFORCYCLES = 8
  };
  const flatbuffers::String *graphId() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPHID);
  }
  const executionGraph::serialization::SocketLink *socketLink() const {
    return GetStruct<const executionGraph::serialization::SocketLink *>(VT_SOCKETLINK);
  }
  bool checkForCycles() const {
    return GetField<uint8_t>(VT_CHECKFORCYCLES, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPHID) &&
           verifier.VerifyString(graphId()) &&
           VerifyFieldRequired<executionGraph::serialization::SocketLink>(verifier, VT_SOCKETLINK) &&
           VerifyField<uint8_t>(verifier, VT_CHECKFORCYCLES) &&
           verifier.EndTable();
  }
};

struct AddConnectionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graphId(flatbuffers::Offset<flatbuffers::String> graphId) {
    fbb_.AddOffset(AddConnectionRequest::VT_GRAPHID, graphId);
  }
  void add_socketLink(const executionGraph::serialization::SocketLink *socketLink) {
    fbb_.AddStruct(AddConnectionRequest::VT_SOCKETLINK, socketLink);
  }
  void add_checkForCycles(bool checkForCycles) {
    fbb_.AddElement<uint8_t>(AddConnectionRequest::VT_CHECKFORCYCLES, static_cast<uint8_t>(checkForCycles), 0);
  }
  explicit AddConnectionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddConnectionRequestBuilder &operator=(const AddConnectionRequestBuilder &);
  flatbuffers::Offset<AddConnectionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddConnectionRequest>(end);
    fbb_.Required(o, AddConnectionRequest::VT_GRAPHID);
    fbb_.Required(o, AddConnectionRequest::VT_SOCKETLINK);
    return o;
  }
};

inline flatbuffers::Offset<AddConnectionRequest> CreateAddConnectionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> graphId = 0,
    const executionGraph::serialization::SocketLink *socketLink = 0,
    bool checkForCycles = false) {
  AddConnectionRequestBuilder builder_(_fbb);
  builder_.add_socketLink(socketLink);
  builder_.add_graphId(graphId);
  builder_.add_checkForCycles(checkForCycles);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddConnectionRequest> CreateAddConnectionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *graphId = nullptr,
    const executionGraph::serialization::SocketLink *socketLink = 0,
    bool checkForCycles = false) {
  return executionGraphGUI::serialization::CreateAddConnectionRequest(
      _fbb,
      graphId ? _fbb.CreateString(graphId) : 0,
      socketLink,
      checkForCycles);
}

struct AddConnectionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CYCLES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<CycleDescription>> *cycles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CycleDescription>> *>(VT_CYCLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CYCLES) &&
           verifier.VerifyVector(cycles()) &&
           verifier.VerifyVectorOfTables(cycles()) &&
           verifier.EndTable();
  }
};

struct AddConnectionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cycles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CycleDescription>>> cycles) {
    fbb_.AddOffset(AddConnectionResponse::VT_CYCLES, cycles);
  }
  explicit AddConnectionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddConnectionResponseBuilder &operator=(const AddConnectionResponseBuilder &);
  flatbuffers::Offset<AddConnectionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddConnectionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddConnectionResponse> CreateAddConnectionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CycleDescription>>> cycles = 0) {
  AddConnectionResponseBuilder builder_(_fbb);
  builder_.add_cycles(cycles);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddConnectionResponse> CreateAddConnectionResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CycleDescription>> *cycles = nullptr) {
  return executionGraphGUI::serialization::CreateAddConnectionResponse(
      _fbb,
      cycles ? _fbb.CreateVector<flatbuffers::Offset<CycleDescription>>(*cycles) : 0);
}

struct RemoveConnectionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPHID = 4,
    VT_SOCKETLINK = 6
  };
  const flatbuffers::String *graphId() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPHID);
  }
  const executionGraph::serialization::SocketLink *socketLink() const {
    return GetStruct<const executionGraph::serialization::SocketLink *>(VT_SOCKETLINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPHID) &&
           verifier.VerifyString(graphId()) &&
           VerifyFieldRequired<executionGraph::serialization::SocketLink>(verifier, VT_SOCKETLINK) &&
           verifier.EndTable();
  }
};

struct RemoveConnectionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graphId(flatbuffers::Offset<flatbuffers::String> graphId) {
    fbb_.AddOffset(RemoveConnectionRequest::VT_GRAPHID, graphId);
  }
  void add_socketLink(const executionGraph::serialization::SocketLink *socketLink) {
    fbb_.AddStruct(RemoveConnectionRequest::VT_SOCKETLINK, socketLink);
  }
  explicit RemoveConnectionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveConnectionRequestBuilder &operator=(const RemoveConnectionRequestBuilder &);
  flatbuffers::Offset<RemoveConnectionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveConnectionRequest>(end);
    fbb_.Required(o, RemoveConnectionRequest::VT_GRAPHID);
    fbb_.Required(o, RemoveConnectionRequest::VT_SOCKETLINK);
    return o;
  }
};

inline flatbuffers::Offset<RemoveConnectionRequest> CreateRemoveConnectionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> graphId = 0,
    const executionGraph::serialization::SocketLink *socketLink = 0) {
  RemoveConnectionRequestBuilder builder_(_fbb);
  builder_.add_socketLink(socketLink);
  builder_.add_graphId(graphId);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoveConnectionRequest> CreateRemoveConnectionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *graphId = nullptr,
    const executionGraph::serialization::SocketLink *socketLink = 0) {
  return executionGraphGUI::serialization::CreateRemoveConnectionRequest(
      _fbb,
      graphId ? _fbb.CreateString(graphId) : 0,
      socketLink);
}

}  // namespace serialization
}  // namespace executionGraphGUI

#endif  // FLATBUFFERS_GENERATED_GRAPHMANIPULATIONMESSAGES_EXECUTIONGRAPHGUI_SERIALIZATION_H_
